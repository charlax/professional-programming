<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
# Table of Contents

- [Professional Programming](#professional-programming)
  - [Must read books](#must-read-books)
  - [Must-read articles](#must-read-articles)
  - [Things to do](#things-to-do)
    - [Coding](#coding)
    - [Incident response (outages, firefighting)](#incident-response-outages-firefighting)
    - [Interviewing](#interviewing)
    - [Managing the database](#managing-the-database)
    - [Reading](#reading)
    - [Releasing & deploying](#releasing-&-deploying)
    - [Testing](#testing)
    - [Writing for performance](#writing-for-performance)
  - [Things to know](#things-to-know)
    - [List of things to know](#list-of-things-to-know)
    - [Know your algorithm and data structures](#know-your-algorithm-and-data-structures)
    - [Know your concepts](#know-your-concepts)
    - [Know your editor](#know-your-editor)
    - [Know your database](#know-your-database)
    - [Know your dev environment](#know-your-dev-environment)
    - [Know your shell](#know-your-shell)
    - [Know your webdesign](#know-your-webdesign)
    - [Know your dotfiles](#know-your-dotfiles)
    - [Know your git](#know-your-git)
    - [Know how to debug](#know-how-to-debug)
    - [Know how to design](#know-how-to-design)
    - [Know how to architect systems](#know-how-to-architect-systems)
    - [Know your programming language](#know-your-programming-language)
    - [Know your design patterns and anti-patterns](#know-your-design-patterns-and-anti-patterns)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Professional Programming

> Give me six hours to chop down a tree and I will spend the first four sharpening the axe. (Abraham Lincoln)

A collection of full-stack resources for programmers.

## Must read books

I've found these books incredibly inspiring:

* [The Pragmatic Programmer: From Journeyman to
  Master](http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X): hands-on the most inspiring and useful book I've read about programming.
* [Code Complete: A Practical Handbook of Software
  Construction](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670): a nice addition to The Programatic Programmer, gives you the necessary framework to talk about code.
* [Release It!](http://www.amazon.com/Release-It-Production-Ready-Pragmatic-Programmers/dp/0978739213): this books goes beyond code and gives you best practices for building production-ready software. It will give you about 3 years worth of real-world experience.
* [Scalability Rules: 50 Principles for Scaling Web
  Sites](http://www.amazon.com/Scalability-Rules-Principles-Scaling-Sites/dp/0321753887)
* [The Linux Programming Interface: A Linux and UNIX System Programming Handbook](http://www.amazon.com/The-Linux-Programming-Interface-Handbook/dp/1593272200): outside of teaching you almost everything you need to know about Linux, this book will give you insights into how software evolves, and the value of having simple & elegant interfaces.

## Must-read articles

* [Practical Advice for New Software Engineers](http://product.hubspot.com/blog/practical-advice-for-new-software-engineers)
* [On Being A Senior Engineer](http://www.kitchensoap.com/2012/10/25/on-being-a-senior-engineer/)
* [Lessons Learned in Software Development](http://henrikwarne.com/2015/04/16/lessons-learned-in-software-development/): one of those articles that give you years of hard-earned lessons, all in one short article. Must read.

## Things to do

### Coding

* [Write code that is easy to delete, not easy to extend](http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to)
* [Lessons learned writing highly available code](https://medium.com/imgur-engineering/lessons-learned-writing-highly-available-code-7eaf3d7aae00#.u7c4j6hac)
* [The Ten Commandments of Egoless Programming](http://blog.codinghorror.com/the-ten-commandments-of-egoless-programming/)

### Incident response (outages, firefighting)

* [Incident Response at Heroku](https://blog.heroku.com/archives/2014/5/9/incident-response-at-heroku)
* [Blameless PostMortems and a Just Culture](https://codeascraft.com/2012/05/22/blameless-postmortems/)

### Interviewing

* [System design interview for IT company](https://github.com/checkcheckzz/system-design-interview)
* [Technical Interview Megarepo](https://github.com/jdsutton/Technical-Interview-Megarepo): study materials for SE/CS technical interviews
* [How to Win the Coding Interview](https://blog.devmastery.com/how-to-win-the-coding-interview-71ae7102d685#.16ph6bp5y)

### Managing the database

* [Safe Operations For High Volume PostgreSQL](https://www.braintreepayments.com/blog/safe-operations-for-high-volume-postgresql/) (this is for PostgreSQL but works great for other db as well).
* [Zero downtime database migrations](https://blog.rainforestqa.com/2014-06-27-zero-downtime-database-migrations/) (code examples are using Rails but this works great for any programming language)

### Reading

* [Papers we love](https://github.com/papers-we-love/papers-we-love): papers from the computer science community to read and discuss. Can be a good source of inspiration of solving your design problems.

### Releasing & deploying

* [How We Release So Frequently](http://engineering.skybettingandgaming.com/2016/02/02/how-we-release-so-frequently/)
* [How to deploy software](https://zachholman.com/posts/deploying-software), Zach Holman
* [BlueGreenDeployment](http://martinfowler.com/bliki/BlueGreenDeployment.html), Martin Fowler
* [Move fast and break nothing](https://zachholman.com/talk/move-fast-break-nothing/), Zach Holman
* [Flipping out](http://code.flickr.net/2009/12/02/flipping-out/), flickr. One of the first articles about feature flags.

### Testing

* [Testing Strategies in a Microservices
Architecture](http://martinfowler.com/articles/microservice-testing/) (Martin Fowler) is an awesome resources explaining how to test a service properly.

### Writing for performance

* [Numbers Everyone Should Know](https://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/)

## Things to know

### List of things to know

* [What every computer science major should know](http://matt.might.net/articles/what-cs-majors-should-know/)

### Know your algorithm and data structures

* Read the [CLRS](https://mitpress.mit.edu/books/introduction-algorithms). You can watch and download the course on [OCW](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/) - there are newer courses as well.
	*  Or [The Algorithm Design Manual](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202?ie=UTF8&qid=1297127794&ref_=sr_1_1&sr=8-1)
* Try out some algorithms on [Project Euler](https://projecteuler.net/)

Let's be honest: algo can be a pretty dry topic. [This quota question](https://www.quora.com/Is-there-a-book-that-teaches-algorithms-data-structures-and-other-computer-science-basics-in-a-fun-way) lists some funnier learning alternative, including:

* [Grokking Algorithms](https://www.amazon.com/dp/1617292230/ref=cm_sw_su_dp)
* [Essential Algorithms](https://www.amazon.com/Essential-Algorithms-Practical-Approach-Computer/dp/1118612108?ie=UTF8&*Version*=1&*entries*=0)

### Know your concepts

* [DDD](https://en.wikipedia.org/wiki/Domain-driven_design)
* [TDD](https://en.wikipedia.org/wiki/Test-driven_development)
* [BDD](https://en.wikipedia.org/wiki/Behavior-driven_development)
* [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem)
* [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming)
* [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)
* [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
* [KISS](https://en.wikipedia.org/wiki/KISS_principle)
* [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
* [GRASP](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))

### Know your editor

* [Sublime Text essential plugins and resources](https://github.com/dreikanter/sublime-bookmarks)
* [vim-awesome](http://vimawesome.com/)

### Know your database

* [A plain english introduction to CAP Theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem/)
* [NOSQL Patterns](http://horicky.blogspot.nl/2009/11/nosql-patterns.html)

### Know your dev environment

* [Awesome Dev Env](https://github.com/jondot/awesome-devenv)

Tools

* [Glances: An eye on your system](https://github.com/nicolargo/glances)
* [HTTPie: a CLI, cURL-like tool for humans](https://github.com/jkbrzt/httpie)
* [jq: command-line JSON processor](https://stedolan.github.io/jq/)
* [tmux: terminal multiplexer](http://tmux.github.io/)
* [htop: an interactive process viewer for Linux](http://hisham.hm/htop/)

### Know your shell

* [Awesome Shell](https://github.com/alebcay/awesome-shell)

Resources

* [Bash Hackers Wiki](http://wiki.bash-hackers.org/)
* [Master the command line, in one page](https://github.com/jlevy/the-art-of-command-line) **must read**

### Know your webdesign

* [Maintainable CSS](http://maintainablecss.com/)

### Know your dotfiles

* [Awesome dotfiles](https://github.com/webpro/awesome-dotfiles)

Articles

* [Setting Up a Mac Dev Machine From Zero to Hero With Dotfiles](http://code.tutsplus.com/tutorials/setting-up-a-mac-dev-machine-from-zero-to-hero-with-dotfiles--net-35449)

### Know your git

* [Git Cheat Sheet](https://github.com/arslanbilal/git-cheat-sheet)
* [git-tips](https://github.com/git-tips/tips)

### Know how to debug

* [Rubber Duck Problem Solving](http://blog.codinghorror.com/rubber-duck-problem-solving/)
* [Five Whys](https://en.wikipedia.org/wiki/5_Whys)
* [The Infinite Hows](http://www.kitchensoap.com/2014/11/14/the-infinite-hows-or-the-dangers-of-the-five-whys/): this provides a strong criticism of the five whys method.
* [Linux Performance Analysis in 60,000 Milliseconds](http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html)

### Know how to design

I highly recommend reading [The Non-Designer's Design Book](http://www.amazon.com/gp/product/0133966151/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=1944687602&pf_rd_s=lpo-top-stripe-1&pf_rd_t=201&pf_rd_i=0321534042&pf_rd_m=ATVPDKIKX0DER&pf_rd_r=1R7MVQP0BCP7GP9VZGYX). This is a pretty short book that will give you some very actionable design advices.

* If you're working on data, Edward Tufte's [The Visual Display of Quantitative Information](http://www.amazon.com/Visual-Display-Quantitative-Information/dp/0961392142/ref=sr_1_1?ie=UTF8&qid=1458046603&sr=8-1&keywords=tufte) is considered a classic.
* The [Universal Principles of Design](http://www.amazon.com/Universal-Principles-Design-Revised-Updated/dp/1592535879/ref=sr_1_1?ie=UTF8&qid=1458046663&sr=8-1&keywords=universal+principles+of+design) will give you enough vocabulary and concepts to describe design challenges into words.

### Know how to architect systems

* [High Scalability](http://highscalability.com/): great blog about system architecture, its weekly review article are packed with numerous insights and interesting technology reviews.
* [6 Rules of thumb to build blazing fast web server applications](http://loige.co/6-rules-of-thumb-to-build-blazing-fast-web-applications/)
* [Deep Lessons From Google And EBay On Building Ecosystems Of Microservices](http://highscalability.com/blog/2015/12/1/deep-lessons-from-google-and-ebay-on-building-ecosystems-of.html)
* [Service oriented architecture: scaling the Uber engineering codebase as we grow](https://eng.uber.com/soa/)
* [The twelve-factor app](http://12factor.net/)
* [Scalable Web Architecture and Distributed Systems](http://www.aosabook.org/en/distsys.html)
* [Introduction to Architecting Systems for Scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [A Distributed Systems Reading List](http://dancres.github.io/Pages/)
* [Services Engineering Reading List](https://github.com/mmcgrana/services-engineering)
* [System Design Cheatsheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)

### Know your programming language

This is language-specific, for instance, checkout my [professional Python education doc](https://github.com/charlax/python-education).

I'd recommend learning:

* At least one dynamic language (Python, Ruby, JavaScript, etc.). Pretty useful for quick one-off automation scripts, and fastest to write for interviews.
* At least one compiled language (Java, C, C++, etc.)
* At least one more recent language to see where the industry is going (as of writing, Go, Swift, Rust, etc.)
* At least one language that has first-class support for functional programming (Haskell, Scala, etc.)

### Know your design patterns and anti-patterns

Here's a list of good books:

* [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/dp/0201633612/): dubbed "the gang of four", this is almost a required reading for any developer. A lot of those are a bit overkill for Python (because everything is an object, and dynamic typing), but the main idea (composition is better than inheritance) definitely is a good philosophy.
* [Patterns of Enterprise Application Architecture](http://www.amazon.com/dp/0321127420/?tag=stackoverfl08-20): learn about how database are used in real world applications. Mike Bayer's SQLAlchemy has been heavily influenced by this book.
* SourceMaking's [Design Patterns](https://sourcemaking.com/design_patterns) seems to be a good web resource too.
* O'Reilly's [How to make mistakes in Python](http://www.oreilly.com/programming/free/files/how-to-make-mistakes-in-python.pdf)
* [101 Design Patterns & Tips for Developers](https://sourcemaking.com/design-patterns-and-tips)

I maintain a [list of antipatterns](https://github.com/charlax/antipatterns) on another repo. This is a highly recommended read.
